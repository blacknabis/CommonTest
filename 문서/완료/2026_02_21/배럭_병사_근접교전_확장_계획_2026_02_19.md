# 배럭 병사 근접교전 확장 계획
> 작성일: 2026-02-19  
> 마지막 보완: 2026-02-19  
> 기준 문서: `문서/진행/타워_영웅_구현_계획_2026_02_19.md`  
> 연동 트래커: `문서/진행/task.md`  
> 대상 프로젝트: Kingdom

## 1. 목표
현재 배럭은 `다중 저지 + 비주얼 병사` 단계다.  
이번 확장은 병사를 실제 전투 유닛으로 승격해 아래 4가지를 완료하는 것을 목표로 한다.

1. 병사별 HP/사망/재소환 루프
2. 병사-적 상호 공격(양방향 피해)
3. 생존 병사 수 기반 다중 저지
4. 기존 배럭 에셋 하위호환 유지

## 2. 베이스라인 (코드 기준)
정합성 기준 파일:
- `Assets/Scripts/Kingdom/Game/Data/TowerConfig.cs`
- `Assets/Scripts/Kingdom/Game/TowerManager.cs`
- `Assets/Scripts/Kingdom/Game/EnemyRuntime.cs`
- `Assets/Scripts/Kingdom/Game/Combat/IDamageable.cs`

현재 상태:
- `BarracksData`는 `SquadSize`, `RallyRange`만 보유
- 병사는 `BarracksSoldierVisual`(렌더 전용), 전투 상태 없음
- 배럭 교전은 `TowerRuntime.TickBarracks`에서 직접 처리
- 적 근접 공격 이벤트는 `EnemyRuntime.AttackPerformed(EnemyRuntime, float)` 사용 가능
- `BaseUnit` 공통 부모는 아직 미도입(본 트랙 Phase A에서 도입)

## 3. 범위
### In Scope
- `BaseUnit` 공통 부모 도입 (`EnemyRuntime`, `BarracksSoldierRuntime`, 추후 `HeroController` 상속 기반)
- `BarracksData` 전투 필드 확장
- `TowerManager` 내부 병사 런타임(상태/HP/재소환) 도입
- `EnemyRuntime.AttackPerformed` 연동으로 적 -> 병사 피해 처리
- 랠리 이동 시 병사/블록 재배치 안정화
- 경량 QA(스모크 + 회귀 체크리스트)

### Out of Scope
- `HeroController`를 즉시 `BaseUnit`으로 마이그레이션하는 실제 코드 변경(후속 트랙)
- 영웅/적 시스템 동시 구조개편
- 병사 아트/애니메이션 고도화
- 장시간 밸런스 최종 고정

## 4. 데이터 설계
### 4.1 `BarracksData` 확장
`Assets/Scripts/Kingdom/Game/Data/TowerConfig.cs`

```csharp
[Serializable]
public struct BarracksData
{
    public int SquadSize;
    public float RallyRange;

    // New
    public float SoldierMaxHp;
    public float SoldierDamage;
    public float SoldierAttackCooldown;
    public float SoldierRespawnSec;
}
```

### 4.2 하위호환 기본값 (Fallback)
`TowerManager.EnsureTowerCombatRules`에서 0값 자동 보정:
- `SoldierMaxHp`: `45f`
- `SoldierDamage`: `max(1f, Levels[0].Damage / max(1, SquadSize))`
- `SoldierAttackCooldown`: `max(0.22f, Levels[0].Cooldown)`
- `SoldierRespawnSec`: `10f`

목적:
- 기존 SO 에셋 즉시 동작
- 현행 체감 난이도 급변 방지

## 5. 런타임 설계
### 5.1. 클래스 구조 (Refactored)
미래의 영웅(Hero) 구현과 코드 중복 최소화를 위해 공통 부모 클래스 `BaseUnit`을 도입한다.

**`Assets/Scripts/Kingdom/Game/BaseUnit.cs`** (New)
```csharp
public abstract class BaseUnit : MonoBehaviour, IDamageable
{
    public float CurrentHp { get; protected set; }
    public float MaxHp { get; protected set; }
    public bool IsAlive => CurrentHp > 0;

    public virtual void ApplyDamage(
        float amount,
        DamageType damageType = DamageType.Physical,
        bool halfPhysicalArmorPenetration = false) { /* common logic */ }

    protected virtual void Die() { /* common death flow */ }
}
```

**`Assets/Scripts/Kingdom/Game/EnemyRuntime.cs`** (Refactor)
- `BaseUnit` 상속으로 변경.
- `IDamageable` 구현부를 부모로 이동하거나 override.
- 고유 로직: Path Following, ReachedGoal, Blocking 처리.

**`Assets/Scripts/Kingdom/Game/BarracksSoldierRuntime.cs`** (New)
- `BaseUnit` 상속.
- 고유 로직: Rally Point Movement, Enemy Blocking, Respawn Loop.

**`Assets/Scripts/Kingdom/Game/HeroController.cs`** (Future Refactor)
- 현재는 `IDamageable` 직접 구현 상태 유지.
- 후속 트랙에서 `BaseUnit` 상속 전환 예정(문서/작업 분리).

### 5.2 병사 상태 머신
`Idle`, `Moving`, `Blocking`, `Dead`, `Respawning`

전이 규칙:
- `Idle -> Blocking`: 블록 대상 배정 성공
- `Idle/Blocking -> Moving`: 랠리 변경
- `Moving -> Idle`: 랠리 도착(`distance <= 0.05f`)
- `Blocking -> Dead`: HP <= 0
- `Dead -> Respawning`: 사망 직후 타이머 시작
- `Respawning -> Idle`: 타이머 완료 + HP 전량 복구

### 5.3 병사 모델 (1차 구현)
`TowerManager` 내부 구조(또는 인접 private type)로 관리:
- `SoldierIndex`, `Transform`, `Renderer`
- `State`, `CurrentHp`
- `AttackCooldownLeft`, `RespawnLeft`
- `EnemyRuntime BlockTarget`

### 5.4 블록 정책
- 병사 1명은 동시에 적 1명만 블록
- 생존 병사 수 만큼만 블록 유지
- 병사 사망 시 즉시 `ReleaseBlock(TowerId)` 호출
- 대상 죽음/이탈 시 병사 `Idle` 복귀

### 5.5 상호 공격 정책
병사 -> 적:
- `Blocking` 상태에서만 공격
- `SoldierAttackCooldown` 주기
- `BlockTarget.ApplyDamage(SoldierDamage, DamageType.Physical, false)`

적 -> 병사:
- 블록된 적의 `AttackPerformed` 구독
- `BaseUnit` 상속으로 인해 `IDamageable`이 보장되므로, 적은 `Target.ApplyDamage()`만 호출하면 됨.

### 5.6 랠리 이동 정책 (확정)
1. 랠리 변경 시 생존 병사 `Moving` 전환
2. 이동 시작 시 기존 블록 즉시 해제
3. 도착 후 `Idle` 전환
4. 이후 블록 판정 재개

## 6. 구현 단계
### Phase A. 구조 리팩토링 및 데이터 확장 (P0)
**목표**: `BaseUnit` 도입 및 기존 `EnemyRuntime` 이관, `BarracksData` 확장.

1. `BaseUnit.cs` 생성 및 공통 멤버(`Hp`, `ApplyDamage` 등) 정의.
2. `EnemyRuntime`이 `BaseUnit`을 상속받도록 리팩토링.
3. `BarracksData` 필드 추가 및 0값 보정 로직 구현.
4. 기존 `Barracks.asset` 로드 점검.

DoD:
- `EnemyRuntime`이 기존과 동일하게 동작함.
- 신규 데이터 필드가 런타임에 안전하게 로드됨.
- `HeroController` 후속 전환을 위한 `BaseUnit` 확장 포인트가 문서화됨.

### Phase B. 병사 런타임 도입 (P0)
작업:
1. `BarracksSoldierRuntime` 구현 (`BaseUnit` 상속)
2. `BarracksSoldierVisual`를 전투 상태 포함 구조로 교체
3. 상태 머신/HP/재소환 타이머 반영
4. 생존 병사 수 기반 블록 슬롯 계산으로 전환

DoD:
- 병사 단위 사망/재소환 루프 동작
- 다중 저지 동작 유지

### Phase C. 상호 공격 연동 (P1)
작업:
1. 병사 공격 루프 연결
2. `AttackPerformed` 구독/해제 루프 연결
3. 사망 시 블록 해제 + 매핑 정리

DoD:
- 적과 병사가 서로 처치 가능
- 이벤트 중복 호출/누수 없음

### Phase D. 랠리 안정화 + 예외 방어 (P1)
작업:
1. 랠리 연속 변경 경합 처리
2. stale target/NullRef 방어 코드 추가

DoD:
- 랠리 연속 변경에서도 상태 꼬임 없음
- 블록 해제 지연 체감 없음

### Phase E. QA + 1차 수치 튜닝 (P1)
작업:
1. 경량 QA 시나리오 실행
2. HP/피해/공속/재소환 수치 1차 보정
3. 결과를 `task.md`와 본 문서에 반영

DoD:
- 치명 버그 0(무한 블록, 영구 무적, NullRef)
- 스모크 통과 또는 이슈 등록 완료

## 7. QA 시나리오 (경량)
1. 기본 생존성: 병사 1명이 적 공격 3~4회 이상 버티는가
2. 재소환 루프: 사망 후 `SoldierRespawnSec ±0.2s` 내 복귀하는가
3. 블록 해제: 병사 사망 시 적이 즉시 이동 재개하는가
4. 다중 교전: 병사 N명 vs 적 N+2에서 상태 불일치 없는가
5. 랠리 스트레스: 랠리를 5회 이상 연속 변경해도 안정적인가
6. 성능 스모크: 10분 플레이 동안 신규 콘솔 에러/급격한 GC 증가가 없는가

## 8. 리스크와 대응
1. 이벤트 누수
- 대응: 구독/해제를 전용 함수로 통일하고 모든 해제 경로에서 호출

2. 매핑 불일치
- 대응: 피해 전달 전 `soldier != null && soldier.IsAlive` 가드

3. 난이도 급변
- 대응: fallback 보수값 적용 후 QA 기반으로만 수치 보정

4. 랠리 경합
- 대응: `선해제 -> 이동 -> 재배정` 순서 고정

## 9. 완료 기준 (Final DoD)
- `BarracksData` 신규 전투 필드가 런타임에 반영됨
- `BaseUnit`이 적/병사의 공통 부모로 동작하며, 영웅 전환을 위한 인터페이스 호환이 유지됨
- 병사 HP/사망/재소환 루프가 안정 동작함
- 적-병사 상호 공격이 실제 처치/해제 결과로 연결됨
- 생존 병사 수 기준 다중 저지가 일관되게 유지됨
- `문서/진행/task.md` Extension Track이 최신 상태로 동기화됨

## 10. 실행 체크리스트
- [x] Phase A 완료
- [x] Phase B 완료
- [x] Phase C 완료
- [x] Phase D 완료
- [x] Phase E 완료
- [x] `task.md` 반영 완료
