# 월드맵에서 전투로 — UI 시스템 완성과 게임씬 설계

> 월드맵 UI를 프로덕션 수준으로 끌어올리고, 게임씬 전투 루프의 설계 문서를 확정한 하루.
> "버튼 하나하나에 시스템이 있고, 전환 하나하나에 설계가 있다."

---

## 🎯 오늘의 목표

1. **월드맵 UI 완성도 향상** — 스테이지 노드, 액션 버튼, 사이드 보더를 프리팹 기반으로 안정화
2. **씬 전환 Fade 효과** — 모든 씬 전환에 FadeOut/FadeIn 적용
3. **게임씬 구현 플랜** — NotebookLM 킹덤러쉬 분석 데이터를 기반으로 전투 루프 설계 문서 작성

---

## 📦 커밋 요약

| 시간 | 커밋 | 내용 |
|------|------|------|
| 16:09 | `a9a937e` | 월드맵 UI 워크플로우, 에셋, 문서 일괄 적용 |
| 17:19 | `501258b` | `UIActionButtonItem` 프리팹 추가 + 하단바 레이아웃 개선 |
| 20:34 | `faf18d5` | `UIStageNode` 고도화 + 사이드보더 실행 플랜 추가 |
| 21:11 | `347805d` | 사이드보더 구조 툴 + SafeArea 바인딩 |
| 21:28 | `0a4937d` | 사이드보더 아트 에셋 생성 + 프리팹 바인딩 |
| 22:14 | `51d8495` | `UIStageNode` 시각 상태 규칙 정리 |

---

## 🏗️ 1. UIStageNode 시스템 고도화

### 문제
스테이지 버튼이 단순 `Button` + `Text`로만 되어 있어, 잠금 상태/클리어 등급/선택 하이라이트를 표현할 수 없었음.

### 해결: 데이터 바인딩 기반 ViewModel

```
StageNodeViewModel
  ├── StageId, StageName
  ├── IsUnlocked, IsBoss
  ├── ClearStars (0~3)
  └── IsSelected

      ↓ 바인딩

UIStageNode (MonoBehaviour)
  ├── 잠금 오버레이 (IsUnlocked = false → 어둡게 + 자물쇠 아이콘)
  ├── 별 표시 (ClearStars → 별 아이콘 1~3개)
  ├── 보스 마커 (IsBoss → 해골 아이콘 표시)
  └── 선택 하이라이트 (IsSelected → 테두리 발광)
```

### 시각 상태 규칙

| 상태 | 배경 | 아이콘 | 인터랙션 |
|------|------|--------|---------|
| 잠금 | 어둡게 | 자물쇠 | 터치 불가 |
| 해금(미클리어) | 기본 | 스테이지 번호 | 터치 가능 |
| 클리어 | 기본 | 별 1~3개 | 터치 가능 |
| 선택됨 | 하이라이트 | 유지 | 선택 연출 재생 |

**핵심:** `IStageUnlockPolicy` 인터페이스로 해금 조건을 분리하여, 선형/분기/조건부 해금을 유연하게 교체할 수 있도록 설계.

---

## 🖼️ 2. 사이드 보더 시스템

### 배경
월드맵 배경 이미지가 16:9 기준으로 제작되었지만, 4:3이나 19.5:9 같은 다른 비율에서 빈 공간이 노출됨.

### 해결 구조

```
WorldMapView
├── Background (Stretch)
├── LeftBorder  ← SafeArea 바깥 영역을 채움
├── RightBorder ← SafeArea 바깥 영역을 채움
└── Content (SafeArea 내부)
```

- **Editor 스크립트**로 사이드보더 구조를 자동 생성 (`WorldMapSideBorderStructureTool`)
- **AI 생성 에셋**을 좌/우 보더에 바인딩
- SafeArea 기준으로 위치/크기 자동 조절

---

## 🔀 3. 씬 전환 Fade 효과

### 변경 내용

`AppManagerBase.ChangeScene()`에 `useFade` 파라미터 추가:

```csharp
public void ChangeScene(TSceneEnum sceneID, bool useFade = true)
```

- **기본값 `true`**: 모든 씬 전환에 FadeOut → 로드 → FadeIn 적용
- **`useFade: false`**: 초기 진입(`InitScene → TitleScene`)처럼 자연스러운 전환에 사용
- **중복 호출 방지**: `_isChangingScene` 플래그로 연타 방어
- **FadeIn 조건부 실행**: `_needsFadeIn` 플래그로 FadeOut 없이 FadeIn만 되는 버그 차단

---

## 📐 4. 게임씬 전투 루프 설계

오늘의 가장 큰 작업은 **게임씬 구현 플랜**을 NotebookLM 킹덤러쉬 분석 데이터를 기반으로 확정한 것.

### NotebookLM에서 추출한 핵심 설계 포인트

| 요소 | 킹덤러쉬 원칙 | 구현 반영 |
|------|-------------|----------|
| **건설 방식** | 자유 배치가 아닌 고정 슬롯 | `StrategicPoint` 배치 시스템 |
| **병영 블로킹** | 유닛이 적을 물리적으로 저지 | 적 상태 FSM (`Moving/Blocked`) |
| **조기 호출** | 리스크 감수 → 골드/쿨타임 보상 | `WaveManager.EarlyCall()` |
| **피해 공식** | 물리(% 감소), 마법(물리방어 무시), 고정(모든 방어 무시) | `DamageType` enum 3종 |
| **포병 관통** | 적 방어력 절반 무시 | 별도 공식 분기 |
| **경제 밸런스** | 항상 부족하게, 선택과 집중 강제 | KPI 기반 튜닝 |
| **별 등급** | 남은 생명력 기준 (스테이지별 개별 설정) | `StarThresholds[]` |

### 5단계 구현 로드맵

```
1단계: 전투 프레임 (FSM)
  └── Prepare → WaveRunning → WaveBreak → Result

2단계: 맵/경로/웨이브
  └── PathManager + WaveConfig/EnemyConfig SO

3단계: 타워/경제/블로킹
  └── TowerManager + InGameEconomyManager + 병영 루프

4단계: 영웅/결과/복귀
  └── HeroController + 저장 + WorldMapReturnAnimator

5단계: Mock 격리/회귀
  └── DEV_MOCK 분기 + 회귀 테스트
```

---

## 💡 핵심 교훈

### 1. NotebookLM을 설계 도구로 쓰기

킹덤러쉬 분석 자료를 NotebookLM에 축적해두니, **"포병의 방어력 관통 공식이 뭐야?"** 같은 구체적인 질의에 정확한 답변을 받을 수 있었다. 게임 디자인 레퍼런스를 체계적으로 관리하면, 구현 단계에서 "감으로 만드는" 실수를 줄일 수 있다.

### 2. KPI를 코드보다 먼저 설계하기

보통 밸런싱은 게임이 어느 정도 완성된 후에 하지만, 이번에는 **계측 지표(KPI)를 구현 플랜 단계에서 먼저 정의**했다:

- `WaveClearTime`, `GoldIncomePerWave`, `EnemyLeakCountByType`…

이 지표들이 먼저 정의되면, 코드를 짤 때 자연스럽게 로깅 포인트를 넣게 되고, "이 값이 어디서 튀는지" 추적이 가능해진다.

### 3. Disposable Tool 패턴의 위력

사이드보더 구조 생성, UIStageNode 검증, 에셋 바인딩 — 이 모든 작업을 **일회성 에디터 스크립트**로 처리하고 즉시 삭제했다. MCP로 개별 오브젝트를 하나씩 조작하는 것보다 **Editor Script API를 활용한 일괄 처리**가 훨씬 안정적이고 재현 가능하다.

---

## 📋 Disposable Tools (생성 → 사용 → 삭제)

```
Assets/Scripts/Kingdom/Editor/
├── WorldMapSideBorderStructureTool.cs    ← 사이드보더 구조 자동 생성
├── WorldMapStageNodeAutoLayoutTool.cs    ← 스테이지 노드 배치 도구
└── WorldMapStageNodeValidationTool.cs    ← 스테이지 노드 프리팹 검증
```

---

## 🔄 오늘의 작업 흐름

```
1. 월드맵 UI 개선 (오전~오후)
   ├── UIActionButtonItem 프리팹 + 레이아웃
   ├── UIStageNode ViewModel 바인딩 + 시각 규칙
   └── 사이드보더 구조/에셋/바인딩

2. 씬 전환 Fade (오후)
   ├── AppManagerBase.ChangeScene() 확장
   ├── _needsFadeIn 플래그 추가
   └── InitScene → TitleScene fade 제외

3. 게임씬 설계 (저녁)
   ├── NotebookLM 질의 4건 (HUD/타워/경제/피해공식/UI인터랙션)
   ├── 기존 플랜 → 보강본 작성 (1차)
   ├── 사용자 편집 (구조 재정리, KPI/위험요소 추가)
   └── 2차 보강 (피해 공식, UI 흐름, 스키마 추가)
```

---

## 📊 수치 요약

| 항목 | 수량 |
|------|------|
| 커밋 | 6건 |
| 신규/수정 스크립트 | ~12개 |
| 프리팹 생성/수정 | 4개 (`UIStageNode`, `UIActionButtonItem`, `WorldMapView`, `SideBorder`) |
| 문서 작성/보강 | 5개 (사이드보더 플랜, 버튼 프리팹 플랜, 게임씬 플랜 등) |
| NotebookLM 질의 | 4건 |
| 컴파일 에러 | 0 (최종 검증 완료) |

---

## 🚀 다음 작업

- [ ] 게임씬 1단계 구현 — `GameStateController` FSM 뼈대
- [ ] `WaveConfig` / `EnemyConfig` ScriptableObject 생성
- [ ] 최소 1개 스테이지의 적 경로 + 웨이브 실행
- [ ] Play 모드에서 월드맵 UI 최종 시각 검증

---

> 타워 디펜스의 재미는 타워를 짓는 게 아니라, **어디에 무엇을 짓지 않을지** 결정하는 데 있다.
> 오늘 설계한 경제 시스템이 그 선택의 무게를 만들어줄 것이다.
